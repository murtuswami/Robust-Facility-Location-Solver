So for each (x,y) for x in closed and y in solutution

We need to figure out which facilities will switch to x when we insert x into the place of y 

2 cases , closest facility is not y , closest facility is y 

in case closest facility not y the solution will reassign only if it is profitable, 
profit = max { 0, cost of its closest - cost to x }

if closest facility is y ( it was originally assigned to y) then we either reassign it to the original second closest facility or to fi. , then profit can be written as 
min(second distance, distance to y) - distance to original ) 


so what we do is for each our our pairs we are swapping in and out, we compute the gain and sort by the greatest gain then that is the neighbour we swap with 

so steps new function returns the highest neighbour from current solution  ( cur)
Also 

highest_neighbour = None 
highest_neighbour_profit = None 
closest_values  = [ ] 
cpened = generateOpenFacilities(cur)
closed = generateClosedFacilities(cur) 
fori, x in enum cur:
closest_values.append( x , second closest to i ) 

for each y in solution
      for each x in closed 
         profit = 0 
           for  n in solution 
                 if cur[n] ! =  y 
                    profit += max (0,distance from y to customer - distance from x to customer)
                else 
                    profit += 
           if highest_neighbour_value = None or profit > highest_neighbour_value 
                set this pair as the highest_neighbour 
                set profit as higher profit 
                
return highest_neighbour_solution

                 

       





